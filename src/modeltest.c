#include <math.h>
#include <stdio.h>

typedef double (*integral_f)(double,double,int);

double values[14] = {
    // Signals (all empty)
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    // Parameters
    1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0
};
int major, minor;   // Major and minor step
double time, timestep;

// GENERATED BY MODELING ENGINE
// ----------------------------
void init(){
    // block 6: sin
    // block 3: gain
    // block 2: gain
    // block 4: gain
    // block 5: pm
    // block 0: int
    // block 1: int
}
void step(integral_f integral){

    int integral_nr = 0;

    // block 6: step
    if(time<=values[8]) values[0] = 0.0;
    else values[0] = values[7];

    // block 3: gain
    values[2] = values[12] * values[5];

    // block 2: gain
    values[4] = values[11] * values[6];

    // block 4: gain
    values[3] = values[13] * values[4];

    // block 5: pm
    values[1] = values[0] - values[2] - values[3];

    // block 0: int
    values[6] = integral(values[1], values[9], integral_nr++);

    // block 1: int
    values[5] = integral(values[4], values[10], integral_nr++);

}
// ----------------------------

// Integrator
// ----------------------------
#include "dynamic_array.h"

typedef struct{
    double state;
} integral_euler_state_t;
d_array_t integral_euler_states;
double integral_euler(double input, double initial, int integral_nr){
    if(integral_euler_states.filled_size<=integral_nr){
        // New integral encountered: expand array
        integral_euler_state_t s = {initial};
        d_array_insert(&integral_euler_states, &s);
    }

    integral_euler_state_t * state = d_array_at(&integral_euler_states, integral_nr);

    state->state = state->state + timestep*input;
    double output = state->state;

    return output;
}
void integral_euler_init(double _timestep){
    time = 0.0;
    timestep = _timestep;
    D_ARRAY_INIT(integral_euler_state_t, &integral_euler_states);
}
void integral_euler_startround(){
    minor = 0;
    major = 1;
}
void integral_euler_endround(){
    time += timestep;
}

// ----------------------------

typedef struct{
    double state;
    double prev;
} integral_trap_state_t;
d_array_t integral_trap_states;
double integral_trap(double input, double initial, int integral_nr){
    if(integral_trap_states.filled_size<=integral_nr){
        // New integral encountered: expand array
        integral_trap_state_t s = {initial, 0.0};
        d_array_insert(&integral_trap_states, &s);
    }

    integral_trap_state_t * state = d_array_at(&integral_trap_states, integral_nr);

    state->state = state->state + timestep/2 * (input + state->prev);
    state->prev = input;
    double output = state->state;

    return output;
}
void integral_trap_init(double _timestep){
    time = 0.0;
    timestep = _timestep/2; // One minor step -> 2 steps per major timestep
    major = 0;
    minor = -1;
    D_ARRAY_INIT(integral_trap_state_t, &integral_trap_states);
}
void integral_trap_startround(){
    minor = ~minor;
    major = ~major;
}
void integral_trap_endround(){
    time += timestep;
}

// ----------------------------

typedef struct{
    double state;
    double prev;
    double prev2;
    double prev3;
} integral_rk4_state_t;
d_array_t integral_rk4_states;
int integral_rk4_minorcounter;
double integral_rk4(double input, double initial, int integral_nr){
    if(integral_rk4_states.filled_size<=integral_nr){
        // New integral encountered: expand array
        integral_rk4_state_t s = {initial, 0.0, 0.0};
        d_array_insert(&integral_rk4_states, &s);
    }

    integral_rk4_state_t * state = d_array_at(&integral_rk4_states, integral_nr);

    state->state = state->state + timestep/3 * (input/2 + state->prev + state->prev2 + state->prev3/2);
    state->prev3 = state->prev2;
    state->prev2 = state->prev;
    state->prev = input;
    double output = state->state;

    return output;
}
void integral_rk4_init(double _timestep){
    time = 0.0;
    timestep = _timestep/4; // Three minor step ->  steps per major timestep
    major = 0;
    minor = -1;
    integral_rk4_minorcounter = 2;
    D_ARRAY_INIT(integral_rk4_state_t, &integral_rk4_states);
}
void integral_rk4_startround(){
    if(minor){
        if(integral_rk4_minorcounter<2){
            integral_rk4_minorcounter++;
        }else{
            minor = ~minor;
            major = ~major;
        }
    }else{
        minor = ~minor;
        major = ~major;
        integral_rk4_minorcounter = 0;
    }
}
void integral_rk4_endround(){
    time += timestep;
}

// ----------------------------

int main(int argc, char ** argv){


    double runtime = 40.0;

    // Open plotter
    FILE * plotter = popen("./plot", "w");
    if(!plotter) return 1;

    d_array_t watchlist;
    D_ARRAY_INIT(int, &watchlist);

    int watch;
    watch = 0; d_array_insert(&watchlist, &watch);
    watch = 1; d_array_insert(&watchlist, &watch);
    watch = 2; d_array_insert(&watchlist, &watch);
    watch = 3; d_array_insert(&watchlist, &watch);
    watch = 4; d_array_insert(&watchlist, &watch);
    watch = 5; d_array_insert(&watchlist, &watch);
    watch = 6; d_array_insert(&watchlist, &watch);

    fprintf(plotter, "cols time timestep ");
    for(int i=0; i<watchlist.filled_size; i++) fprintf(plotter, "s%d ", *(int*)d_array_at(&watchlist, i));
    fprintf(plotter, "\n");
    fprintf(plotter, "data\n");

    integral_rk4_init(0.1);
    init();
    while(time<=runtime){
        integral_rk4_startround();

        step(integral_rk4);

        if(major){
            fprintf(plotter, "%e %e ", time, timestep);
            for(int i=0; i<watchlist.filled_size; i++) fprintf(plotter, "%e ", values[*(int*)d_array_at(&watchlist, i)]);
            fprintf(plotter, "\n");
        }

        integral_rk4_endround();
    }

    fprintf(plotter, "e\n");

    fprintf(plotter, "plot 1,1 x:time y:s4:label:f yrange:-1.5:1.5 p\n");
    fprintf(plotter, "csv rk4.csv time s4\n");

    fprintf(plotter, "X\n");
    pclose(plotter);

    return 0;
}